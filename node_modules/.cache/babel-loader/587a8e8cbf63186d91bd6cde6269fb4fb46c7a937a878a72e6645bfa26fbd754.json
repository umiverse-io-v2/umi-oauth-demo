{"ast":null,"code":"import crypto from 'crypto';\nexport function encrypt(text, secretKey) {\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(secretKey), iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return iv.toString('hex') + ':' + encrypted;\n}\nexport function decrypt(encryptedData, secretKey) {\n  const [ivHex, encryptedText] = encryptedData.split(':');\n  const iv = Buffer.from(ivHex, 'hex');\n  const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(secretKey), iv);\n  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n}\nexport function createSecretKey() {\n  const secretKey = crypto.randomBytes(32);\n  const secretKeyHex = secretKey.toString('hex');\n  return secretKeyHex;\n}\nexport function restoreSecretKey(secretKeyHex) {\n  const secretKey = Buffer.from(secretKeyHex, 'hex');\n  return secretKey;\n}","map":{"version":3,"names":["crypto","encrypt","text","secretKey","iv","randomBytes","cipher","createCipheriv","Buffer","from","encrypted","update","final","toString","decrypt","encryptedData","ivHex","encryptedText","split","decipher","createDecipheriv","decrypted","createSecretKey","secretKeyHex","restoreSecretKey"],"sources":["/Users/laifu/Documents/umiverse.io/repo_v2/umi-oauth-demo/src/utils/AES.tsx"],"sourcesContent":["import crypto from 'crypto';\n\nexport function encrypt(text: string, secretKey: Buffer) {\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(secretKey), iv);\n\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n\n  return iv.toString('hex') + ':' + encrypted;\n}\n\nexport function decrypt(encryptedData: string, secretKey: Buffer) {\n  const [ivHex, encryptedText] = encryptedData.split(':');\n  const iv = Buffer.from(ivHex, 'hex');\n  const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(secretKey), iv);\n\n  let decrypted = decipher.update(encryptedText, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n\n  return decrypted;\n}\n\nexport function createSecretKey() {\n  const secretKey = crypto.randomBytes(32);\n  const secretKeyHex = secretKey.toString('hex');\n  return secretKeyHex;\n}\n\nexport function restoreSecretKey(secretKeyHex: string) {\n  const secretKey: Buffer = Buffer.from(secretKeyHex, 'hex');\n  return secretKey;\n}\n"],"mappings":"AAAA,OAAOA,MAAM,MAAM,QAAQ;AAE3B,OAAO,SAASC,OAAOA,CAACC,IAAY,EAAEC,SAAiB,EAAE;EACvD,MAAMC,EAAE,GAAGJ,MAAM,CAACK,WAAW,CAAC,EAAE,CAAC;EACjC,MAAMC,MAAM,GAAGN,MAAM,CAACO,cAAc,CAAC,aAAa,EAAEC,MAAM,CAACC,IAAI,CAACN,SAAS,CAAC,EAAEC,EAAE,CAAC;EAE/E,IAAIM,SAAS,GAAGJ,MAAM,CAACK,MAAM,CAACT,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC;EAClDQ,SAAS,IAAIJ,MAAM,CAACM,KAAK,CAAC,KAAK,CAAC;EAEhC,OAAOR,EAAE,CAACS,QAAQ,CAAC,KAAK,CAAC,GAAG,GAAG,GAAGH,SAAS;AAC7C;AAEA,OAAO,SAASI,OAAOA,CAACC,aAAqB,EAAEZ,SAAiB,EAAE;EAChE,MAAM,CAACa,KAAK,EAAEC,aAAa,CAAC,GAAGF,aAAa,CAACG,KAAK,CAAC,GAAG,CAAC;EACvD,MAAMd,EAAE,GAAGI,MAAM,CAACC,IAAI,CAACO,KAAK,EAAE,KAAK,CAAC;EACpC,MAAMG,QAAQ,GAAGnB,MAAM,CAACoB,gBAAgB,CAAC,aAAa,EAAEZ,MAAM,CAACC,IAAI,CAACN,SAAS,CAAC,EAAEC,EAAE,CAAC;EAEnF,IAAIiB,SAAS,GAAGF,QAAQ,CAACR,MAAM,CAACM,aAAa,EAAE,KAAK,EAAE,MAAM,CAAC;EAC7DI,SAAS,IAAIF,QAAQ,CAACP,KAAK,CAAC,MAAM,CAAC;EAEnC,OAAOS,SAAS;AAClB;AAEA,OAAO,SAASC,eAAeA,CAAA,EAAG;EAChC,MAAMnB,SAAS,GAAGH,MAAM,CAACK,WAAW,CAAC,EAAE,CAAC;EACxC,MAAMkB,YAAY,GAAGpB,SAAS,CAACU,QAAQ,CAAC,KAAK,CAAC;EAC9C,OAAOU,YAAY;AACrB;AAEA,OAAO,SAASC,gBAAgBA,CAACD,YAAoB,EAAE;EACrD,MAAMpB,SAAiB,GAAGK,MAAM,CAACC,IAAI,CAACc,YAAY,EAAE,KAAK,CAAC;EAC1D,OAAOpB,SAAS;AAClB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}